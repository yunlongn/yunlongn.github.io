<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL(十三)：小一万字+14张图读懂锁机制 - 云扬四海</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="云扬四海"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="云扬四海"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="MySQL中的锁有很多种，各种锁应用在不同的地方。「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」。 MySQL中锁总的来说有两种概念：Lock和Latch  Latch 称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL(十三)：小一万字+14张图读懂锁机制"><meta property="og:url" content="http://ityouknow.cn/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="云扬四海"><meta property="og:description" content="MySQL中的锁有很多种，各种锁应用在不同的地方。「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」。 MySQL中锁总的来说有两种概念：Lock和Latch  Latch 称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129088.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129164.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129134.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129128.png"><meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="><meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129096.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129018.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129295.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129385.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129438.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129440.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129459.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129485.png"><meta property="article:published_time" content="2021-08-06T08:13:00.000Z"><meta property="article:modified_time" content="2022-08-06T09:34:16.292Z"><meta property="article:author" content="yunlongn"><meta property="article:tag" content="Mysql"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129088.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ityouknow.cn/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/"},"headline":"云扬四海","image":["https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129088.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129164.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129134.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129128.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129096.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129018.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129295.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129385.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129438.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129440.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129459.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129485.png"],"datePublished":"2021-08-06T08:13:00.000Z","dateModified":"2022-08-06T09:34:16.292Z","author":{"@type":"Person","name":"yunlongn"},"description":"MySQL中的锁有很多种，各种锁应用在不同的地方。「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」。 MySQL中锁总的来说有两种概念：Lock和Latch  Latch 称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁"}</script><link rel="canonical" href="http://ityouknow.cn/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.8.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">云扬四海</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">列表</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/yun/fireworks.html">fireworks</a><a class="navbar-item" href="/yun/sheep.html">sheep</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="http://github.com/yunlongn"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-06T08:13:00.000Z" title="2021-08-06T08:13:00.000Z">2021-08-06</time>发表</span><span class="level-item"><time dateTime="2022-08-06T09:34:16.292Z" title="2022-08-06T09:34:16.292Z">2022-08-06</time>更新</span><span class="level-item"> yunlongn </span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/">Mysql</a></span><span class="level-item">1 小时读完 (大约8987个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL(十三)：小一万字+14张图读懂锁机制</h1><div class="content"><p>MySQL中的锁有很多种，各种锁应用在不同的地方。<strong>「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」</strong>。</p>
<p>MySQL中锁总的来说有两种概念：Lock和Latch</p>
<ul>
<li><p>Latch</p>
<p>称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁）。</p>
</li>
<li><p>Lock</p>
<p><strong>「Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行」</strong>。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p>
<a id="more"></a>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129088.png" alt="图片"></p>
</li>
</ul>
<h2 id="一、锁的分类"><a href="#一、锁的分类" class="headerlink" title="一、锁的分类"></a><strong>一、锁的分类</strong></h2><p>实际上MySQL的锁在不同的维度上划分是多种多样的，在特地的场景下，发挥不一样的作用，下面来看看锁的分类。</p>
<ul>
<li><p><strong>「锁定的粒度（加锁的范围）划分」</strong></p>
</li>
<li><ul>
<li><p><strong>「全局锁」</strong></p>
<p><strong>「对整个数据库加锁」</strong>。</p>
<p>应用场景是<strong>「做全库的逻辑备份」</strong>。</p>
</li>
<li><p><strong>「表锁」</strong></p>
<p><strong>「每次操作锁住整张表」</strong>。锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>应用在MyISAM、InnoDB、BDB 等存储引擎中。</p>
</li>
<li><p><strong>「页锁」</strong></p>
<p><strong>「每次锁定相邻的一组记录」</strong>，锁定粒度、开销和加锁时间都界于表锁和行锁之间，并发度一般。</p>
<p>应用在BDB 存储引擎中</p>
</li>
<li><p><strong>「行锁」</strong></p>
<p>每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB 存储引擎中。</p>
</li>
</ul>
</li>
<li><p><strong>「操作类型划分」</strong></p>
</li>
<li><ul>
<li><p><strong>「读锁（S锁）」</strong></p>
<p>共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
</li>
<li><p><strong>「写锁（X锁）」</strong></p>
<p>排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。</p>
</li>
<li><p><strong>「意向锁」</strong></p>
<p>InnoDB支持多粒度的锁，允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持 一种特有锁<strong>「意向锁」</strong>。分为意向读锁（IS锁）、意向写锁（IX锁）。</p>
</li>
</ul>
</li>
<li><p><strong>「锁的机制上划分」</strong></p>
</li>
<li><ul>
<li><p><strong>「乐观锁」</strong></p>
<p>操作数据时不会对操作的数据进行加锁，只是对记录的版本进行比对，在数据更新提交的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</p>
</li>
<li><p><strong>「悲观锁」</strong></p>
<p>在对一条数据修改的时候，为了避免同时被其他事物修改，在修改数据之前先锁定，再修改数据的方式。共享锁和排他锁是悲观锁的不同实现。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129164.png" alt="图片"></p>
<h2 id="二、全局锁"><a href="#二、全局锁" class="headerlink" title="二、全局锁"></a><strong>二、全局锁</strong></h2><h3 id="2-1-什么是全局锁"><a href="#2-1-什么是全局锁" class="headerlink" title="2.1 什么是全局锁"></a>2.1 什么是全局锁</h3><p><strong>「全局锁，即对整个数据库实例加锁」</strong>。一般当我们需要让整个库处于只读状态的时候，可以给数据库加上全局锁。<strong>「加上全局锁之后其他线程的：数据更新语句（增删改）、数据定义语句（包括建表、修改表结构等）都会被阻塞」</strong>。</p>
<ul>
<li><p><strong>「加锁方式」</strong></p>
<p>MySQL提供了一个加全局读锁的方法，命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock (FTWRL)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「全局锁应用场景」</strong></p>
<p><strong>「做全库逻辑备份」</strong>。即把整库每个表都select出来保存成文本。</p>
</li>
</ul>
<p><strong>「通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。在备份过程中整个库完全处于【只读状态】」</strong>。但是整个库都只能读不能写，会有很大的弊端：</p>
<ul>
<li>如果在主库上备份。那么在备份期间都不能执行写入操作。</li>
<li>如果在从库上备份。那么在备份期间，从库不能执行主库同步过来的 binlog，从而造成主从延时。</li>
</ul>
<p>由此可见，做全库逻辑备份的时候加全局锁，对系统的影响非常的大，既然如此，为什么要加全局锁呢？</p>
<h3 id="2-2-为什么要加全局锁"><a href="#2-2-为什么要加全局锁" class="headerlink" title="2.2 为什么要加全局锁"></a>2.2 为什么要加全局锁</h3><p>先来看一个案例：</p>
<blockquote>
<p>假设现在数据库中现在有两张表：账户余额表，订单表，当我们下一个订单时，会扣减余额，同时在订单表中写入一个订单记录。</p>
</blockquote>
<p>下面通过图解来说明对这两张表进行备份的过程，由于备份数据又先后顺序，所以分两种情况来看</p>
<ul>
<li><p><strong>「先备份账户余额表，再备份订单表」</strong></p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129134.png" alt="图片"></p>
<blockquote>
<p>由图可以看出：先备份账户余额表，再备份订单表导致备份数据中账户余额没扣钱，但是订单有了，商家血亏，消费者乐的不行，这肯定是不允许发生的。</p>
</blockquote>
</li>
<li><p><strong>「先备份订单表，再备份账户余额表」</strong></p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129128.png" alt="图片"></p>
<blockquote>
<p>由图可以看出：先备份订单表，再备份账户余额表导致备份数据中账户余额扣了钱，但是订单没有了，商家白嫖，消费者肯定不干，这肯定也是不允许发生的。</p>
</blockquote>
</li>
</ul>
<p>案例结论：</p>
<p><strong>「通过上述案例说明，不加锁的话，备份系统备份的得到的数据不一致的，其实就是数据一个逻辑时间点的，这个读视图【Read View】是逻辑不一致的」</strong>。</p>
<h3 id="2-3-不加全局锁行不行"><a href="#2-3-不加全局锁行不行" class="headerlink" title="2.3 不加全局锁行不行"></a>2.3 不加全局锁行不行</h3><p><strong>「通过上述的描述，我们知道在做数据备份的时候，需要加全局锁（FTWRL）来保证数据的一致性，但是由于FTWRL需要关闭所有表对象，数据库禁止写入，执行命令时容易导致数据库hang住」</strong>。</p>
<blockquote>
<p>Q：既然加全局锁会影响业务，危害大，那做备份的时候有没有不用FTWRL，又能保证数据一致性的方法呢？A：有，方法是由有的，但是有局限性</p>
</blockquote>
<ul>
<li><p><strong>「不加全局锁怎么保证数据一致性」</strong></p>
</li>
<li><ul>
<li><p>在之前文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIxMDU5OTU1Mw==&mid=2247485973&idx=1&sn=5bf8d02d361bc36d32472aa5f2071e8e&scene=21#wechat_redirect">《MVCC多版本并发控制》</a>的3.3可重复读（RR）MVCC实现原理一节中有提到，<strong>「可重复读隔离级别下【同一个事务里面，多次查询，都只会产生一个共用Read View】」</strong>，<strong>「因此我们将事物的隔离级别调整为可重复读（RR）时是可以得到一致性视图的，而一致性视图通过MVCC能够确保数据的逻辑一致性」</strong>。</p>
</li>
<li><p><strong>「MySQL官方提供了一个逻辑备份工具是【mysqldump】。当mysqldump使用参数 -single-transaction 时，备份数据之前会启动一个事务，在这个事务内生成一致性视图。基于MVCC，备份过程中数据是可以正常更新」</strong>。</p>
<blockquote>
<p>–single-transaction：设置事务的隔离级别为可重复读(REPEATABLE READ)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>「一致性视图局限性」</strong></p>
<p><strong>「一致性视图实现的前提是事物的隔离级别是可重复读（RR），但是不是所有的引擎都支持事物的，如果使用的MyISAM引擎，一致性视图就无法使用，只能FTWRL命令」</strong>。</p>
<blockquote>
<p>MyISAM引擎不支持事务，总是能够拿到最新的数据</p>
</blockquote>
</li>
</ul>
<h3 id="2-4数据库只读能否替换FTWRL"><a href="#2-4数据库只读能否替换FTWRL" class="headerlink" title="2.4数据库只读能否替换FTWRL"></a>2.4数据库只读能否替换FTWRL</h3><p><strong>「FTWRL的本质就是给数据库加一个锁，禁止其他线程写入，也就是将数据库设置成了只读状态」</strong>。数据库设置为只读状态其实还有一种更简单的方式，直接使用以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global readonly&#x3D;true</span><br></pre></td></tr></table></figure>
<p>但是一般不推荐使用readonly，两者比较，还是推荐使用FTWRL</p>
<ul>
<li><p><strong>「readonly的值有时候会被用来做其他逻辑判断，修改global变量影响更大」</strong></p>
<blockquote>
<p>判断一个库是主库还是备库</p>
</blockquote>
</li>
<li><p><strong>「当备份过程中出现异常时：」</strong></p>
</li>
<li><ul>
<li>FTWRL命令会释放全局锁，数据库可以被其他线程正常读写</li>
<li>设置为readonly时，由于时全局变量，数据库就会一直保持readonly状态，直到改变readonly的值</li>
</ul>
</li>
</ul>
<h2 id="三、表锁"><a href="#三、表锁" class="headerlink" title="三、表锁"></a><strong>三、表锁</strong></h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（metadata lock，MDL)。</p>
<h3 id="3-1表锁"><a href="#3-1表锁" class="headerlink" title="3.1表锁"></a>3.1表锁</h3><p><strong>「表级别的锁定是MySQL各【存储引擎中】最大颗粒度的锁定机制」</strong>。由于直接锁定一张表，所以获取锁和释放锁的速度很快，避免了死锁问题，但是出现锁定资源争用的概率也最高，并发量降低。</p>
<ul>
<li><p><strong>「表锁的加锁语法」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#隐式上锁（默认，自动加锁自动释放</span><br><span class="line">insert、update、delete &#x2F;&#x2F;上写锁</span><br><span class="line">#显式上锁（手动）</span><br><span class="line">lock table tableName read;&#x2F;&#x2F;读锁</span><br><span class="line">lock table tableName write;&#x2F;&#x2F;写锁</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「表锁的释放锁语法」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端断开的时候也会自动释放锁。</p>
</blockquote>
</li>
<li><p><strong>「查看表上加过的锁」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show open tables;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>「MyISAM引擎默认的锁是表锁」</strong>。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</p>
<ul>
<li><p><strong>「表级读锁」</strong></p>
<p>当前表加read锁，当前连接和其他的连接都可以读操作；但是当前连接写操作会报错，其他连接写操作会被阻塞。</p>
</li>
<li><p><strong>「表级写锁」</strong></p>
<p>当前表加write锁，当前连接可以对表做读写操作，其他连接对该表所有操作（读写操作）都被阻塞。</p>
</li>
</ul>
<p><strong>「表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞」</strong>。</p>
<h3 id="3-2元数据锁（metadata-lock，MDL"><a href="#3-2元数据锁（metadata-lock，MDL" class="headerlink" title="3.2元数据锁（metadata lock，MDL)"></a>3.2元数据锁（metadata lock，MDL)</h3><blockquote>
<p>当我们查询查询一个表中的数据时，另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构就不一致了，这肯定是允许。这里就用到了元数据锁</p>
</blockquote>
<p>在MySQL 5.5版本中引入了MDL，<strong>「元数据锁(MDL) 不需要显式使用，在访问一个表的时候会被自动加上」</strong>。</p>
<ul>
<li><p><strong>「当对一个表做增删改查的时候会加上【MDL读锁】」</strong></p>
<p>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查操作。</p>
</li>
<li><p><strong>「当对一个表做结构变更的时候会加上【MDL写锁】」</strong></p>
<p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。</p>
</li>
</ul>
<h2 id="四、页锁"><a href="#四、页锁" class="headerlink" title="四、页锁"></a><strong>四、页锁</strong></h2><ul>
<li>页级锁定是<strong>「MySQL中比较独特」</strong>的一种锁定级别，在其他数据库管理软件中并不常见。</li>
<li>页级锁定和行级锁定一样，会发生死锁</li>
<li>使用页级锁定的主要是BerkeleyDB存储引擎。</li>
<li>开销和加锁时间界于表锁和行锁之间；</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>页锁应用于 BDB 引擎，一般很少见，了解一下即可，重点理解下行锁</p>
<h2 id="五、行锁"><a href="#五、行锁" class="headerlink" title="五、行锁"></a><strong>五、行锁</strong></h2><h3 id="5-1行锁是什么"><a href="#5-1行锁是什么" class="headerlink" title="5.1行锁是什么"></a>5.1行锁是什么</h3><p><strong>「行锁顾名思义就是对数据行进行加锁。行锁的锁定颗粒度在 MySQL中是最细的，应用于 InnoDB 存储引擎，通过对索引数据页上的记录加锁实现的【即行锁是针对索引加锁】」</strong>。</p>
<ul>
<li><p><strong>「行锁的优缺点」</strong></p>
<p>并发情况下，产生锁等待的概率较低，支持较大的并发数，但开销大，加锁慢，而且会出现死锁。</p>
</li>
<li><p><strong>「行锁的前提条件」</strong></p>
<p><strong>「检索数据时需要通过索引，【因为 InnoDB 是通过给索引的索引项加锁来实现行锁的】」</strong>。</p>
</li>
<li><ul>
<li>在不通过索引条件查询的时候，InnoDB 会使用表锁，表锁会产生锁冲突</li>
<li><strong>「行锁是针对索引加锁」</strong>，所以即使访问的不同记录，只要使用的是同一索引项，也可能会出现锁冲突。</li>
</ul>
</li>
</ul>
<blockquote>
<p>MySQL会比较不同执行计划，当全表扫描比索引效率更高时，InnoDB就使用表锁。因此不一定使用了索引就一定会使用行锁，也有可能使用表锁。</p>
</blockquote>
<ul>
<li><p><strong>「行锁会产生死锁」</strong></p>
<p>在我之前文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIxMDU5OTU1Mw==&mid=2247486053&idx=1&sn=68df57143f97a37dd46c6409a1cb0b88&scene=21#wechat_redirect">《索引分析》</a>中的回表查询有提到，当我们走辅助索引的时候，会扫两遍索引树，如下：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>「实际上InnoDB 的行锁也是分为两步获得的：锁住主键索引，锁住非主键索引」</strong>。</p>
<blockquote>
<p>当两个事务同时执行时，</p>
<p>一个锁住了主键索引，在等待其他索引；</p>
<p>另一个锁住了非主键索引，在等待主键索引，</p>
<p>这样就可能会发生死锁。</p>
</blockquote>
<p><strong>「InnoDB可以检测到这种死锁，检测到后会让其中一个事务释放锁回退，另一个获取锁完成事务」</strong>。</p>
</li>
</ul>
<h3 id="5-2行锁的实现算法"><a href="#5-2行锁的实现算法" class="headerlink" title="5.2行锁的实现算法"></a>5.2行锁的实现算法</h3><p>前面讲到<strong>「InnoDB行锁是通过对 索引数据页上的记录加锁实现的」</strong>，接下来看看它具体是怎么实现，</p>
<p>InnoDB存储引擎有3种实现行锁的算法：</p>
<ul>
<li><p><strong>「【Record Lock】：记录锁，单个行记录上的锁」</strong></p>
<p>RC、RR隔离级别都支持，如果表中没有主键和任何一个索引，那InnoDB会使用隐式的主键来进行锁定。</p>
</li>
<li><p><strong>「【Gap Lock】：间隙锁，锁定一个范围，但不包含记录本身」</strong></p>
<p>范围锁，锁定索引记录范围，确保索引记录的间隙不变，RR隔离级别支持</p>
</li>
<li><p><strong>「【Next-Key Lock】：Gap Lock与Record Lock的组合」</strong></p>
<p>锁定数据前后范围，并且锁定记录本身，RR隔离级别支持</p>
</li>
</ul>
<p><strong>「在RR隔离级别，InnoDB对于行的查询都是采用【Next-Key Lock】的组合锁定算法」</strong>，但是<strong>「在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock，仅锁住索引本身而非范围」</strong>。</p>
<p>下面具体看下针对不同的sql语句采用的是那种加锁方式：</p>
<ul>
<li><p>查询语句类型一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from  ...</span><br></pre></td></tr></table></figure>
<p><strong>「对于普通的select语句，InnoDB引擎采用MVCC机制实现非阻塞读，【InnoDB引擎不加锁】」</strong>。</p>
</li>
<li><p>查询语句类型二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure>
<p><strong>「添加共享锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</strong>。</p>
</li>
<li><p>查询语句类型三</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from ... for update</span><br></pre></td></tr></table></figure>
<p><strong>「添加排他锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</strong>。</p>
</li>
<li><p>修改语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update ... from ... where  ...</span><br></pre></td></tr></table></figure>
<p><strong>「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</strong>。</p>
</li>
<li><p>删除语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete ... from ... where</span><br></pre></td></tr></table></figure>
<p><strong>「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</strong>。</p>
</li>
<li><p>插入语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert ... from  ...</span><br></pre></td></tr></table></figure>
<p><strong>「InnoDB会在将要插入的那一行设置一个排他的RecordLock锁」</strong>。</p>
</li>
</ul>
<h2 id="六、读锁-写锁-意向锁"><a href="#六、读锁-写锁-意向锁" class="headerlink" title="六、读锁/写锁/意向锁"></a><strong>六、读锁/写锁/意向锁</strong></h2><p>在前文中提到的锁类型按照<strong>「操作类型划分」</strong>有<strong>「读锁（S锁），写锁（X锁）」</strong>，其实它们与共享锁，排他锁是一个意思，只是不同叫法而已。</p>
<h3 id="6-1共享锁（行级锁-读锁-S锁）"><a href="#6-1共享锁（行级锁-读锁-S锁）" class="headerlink" title="6.1共享锁（行级锁-读锁/S锁）"></a>6.1共享锁（行级锁-读锁/S锁）</h3><p><strong>「共享锁（Shared Lock）又称为读锁，简称S锁，是一种行级锁」</strong>。</p>
<p>顾名思义：<strong>「共享锁就是多个事务对于同一数据共享一把锁，都能访问到数据，但是只能读不能修改」</strong>。</p>
<ul>
<li><p><strong>「加锁方式」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「释放方式」</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「共享锁工作原理」</strong></p>
<p><strong>「一个事务获取了一条记录的共享锁后，其他事务也能获得该记录对应的共享锁，但不能获得排他锁」</strong>。即一个事务使用了共享锁（读锁），其他事务只能读取，不能写入，写操作被阻塞。</p>
</li>
</ul>
<h3 id="6-2排他锁（行级锁-写锁-X锁）"><a href="#6-2排他锁（行级锁-写锁-X锁）" class="headerlink" title="6.2排他锁（行级锁-写锁/X锁）"></a>6.2排他锁（行级锁-写锁/X锁）</h3><p><strong>「排他锁（EXclusive Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」</strong>。</p>
<p>顾名思义：<strong>「排他锁就是不能与其他锁并存，即当前写操作没有完成前，会阻断其他写锁和读锁」</strong>。</p>
<ul>
<li><p><strong>「加锁方式」</strong></p>
<p>innodb引擎默认会在update，delete语句加上 for update</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「释放方式」</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>「共享锁工作原理」</strong></p>
<p><strong>「如一个事务获取了一条记录的排他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁（共享锁、排他锁），但是获取到排他锁的事务可以对数据进行读写操作」</strong>。</p>
<blockquote>
<p>这里要注意一下，其他事务不加锁的读是不会被阻塞的，阻塞的是加锁的读</p>
</blockquote>
</li>
<li><p><strong>「排他锁为什么是一种行锁也是表锁」</strong></p>
<p>innodb引擎默认会在update，delete语句加上 for update</p>
<p><strong>「读锁，写锁都属于行级锁，行级锁的实现是依靠其对应的索引，如果没用到索引的查询，就会走表锁」</strong>。</p>
</li>
<li><ul>
<li><p>有索引：以索引列为条件更新数据，会存在间隙锁，行锁，页锁，而锁住一部分行。</p>
</li>
<li><p>没有索引：更新数据时会锁住整张表。</p>
</li>
<li><p><strong>「可重复读隔离级别下」</strong></p>
</li>
<li><p><strong>「串行化隔离级别下」</strong></p>
<p>读写数据都会锁住整张表</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-3意向锁（表锁）"><a href="#6-3意向锁（表锁）" class="headerlink" title="6.3意向锁（表锁）"></a>6.3意向锁（表锁）</h3><h4 id="6-1-意向锁是什么"><a href="#6-1-意向锁是什么" class="headerlink" title="6.1 意向锁是什么"></a>6.1 意向锁是什么</h4><p><strong>「意向锁（Intention Lock）简称I锁，是一种表级锁」</strong>。</p>
<p><strong>「InnoDB 实现了标准的行级锁，包括：共享锁（S锁）、排它锁（X锁）」</strong>，那么为什么需要引入意向锁呢？意向锁解决了什么问题？</p>
<blockquote>
<p>假设，事务A获取了某一行记录的排它锁，事物A尚未提交,事务B想要获取表锁时，则事物B必须要确认表的每一行都不存在排他锁，需要进行全表扫描，效率很低，此时就引入意向锁</p>
</blockquote>
<ul>
<li>如果事务A获取了某一行记录的排它锁，实际此时表存在两种锁，行记录的排他锁和表上的意向排他锁。</li>
<li>如果事务B试图在该表加表级锁时，则会被意向锁阻塞，因此事物B不必检查各个页锁或行锁，而只需检查表上的意向即可。</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>如上，数据库中存储数据，范围由大到小：表–&gt;页–&gt;行，加锁也是分别加在表–&gt;页–&gt;行中，当我们把锁加在更大一级范围时，也就不需要全表扫描下一级的某些锁，可以很大程度提升性能。</p>
<p><strong>「锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，即意向锁」</strong></p>
<p>通过上述描述我们知道<strong>「意向锁是加在表上，用于防止全表扫描的一种锁，即意向锁是表锁」</strong>。意向锁分为两种类型：</p>
<ul>
<li><strong>「意向共享锁（intention shared lock）」</strong>简称IS锁，事务想要给某一个数据行加行级共享锁（S锁）之前必须先获取该表的IS锁（表级锁）</li>
<li><strong>「意向排他锁（intention exclusive lock）」</strong>简称IX锁，事务想要给某一个数据行加行级排他锁（X锁）之前必须先获取该表的IX锁（表级锁）</li>
</ul>
<p><strong>「【意向锁都是InnoDB存储引擎自己维护的,用户是无法操作意向锁的】」</strong>。</p>
<p>【<strong>「在为数据行加共享锁/排他锁之前，InooDB会先获取该数据行所在在数据表的对应意向锁(表级锁)」</strong>】，如果没有获取到，否则等待innodb_lock_wait_timeout超时后根据innodb_rollback_on_timeout决定是否回滚事务。</p>
<blockquote>
<p>从锁粒度角度：InnoDB 允许行级锁与表级锁共存,而意向锁是表锁；</p>
<p>从锁模式角度：意向锁是一种独立类型，辅助解决记录锁效率不及的问题；</p>
<p>从兼容性角度：意向锁包含了共享/排他两种。</p>
</blockquote>
<h4 id="6-2-意向锁的兼容互斥性"><a href="#6-2-意向锁的兼容互斥性" class="headerlink" title="6.2 意向锁的兼容互斥性"></a>6.2 意向锁的兼容互斥性</h4><ul>
<li>意向锁之间的兼容互斥性：意向锁之间是互相兼容的</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">意向共享锁（IS）</th>
<th align="left">意向排他锁（IX）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">意向共享锁（IS）</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">意向排他锁（IX）</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<ul>
<li>意向锁与其他锁兼容互斥性：意向锁与普通的排他锁/共享锁互斥</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">意向共享锁（IS）</th>
<th align="left">意向排他锁（IX）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">表级共享锁（S）</td>
<td align="left">兼容</td>
<td align="left">互斥</td>
</tr>
<tr>
<td align="left">表级排他锁（X）</td>
<td align="left">互斥</td>
<td align="left">互斥</td>
</tr>
</tbody></table>
<p><strong>「上述的排他锁（X锁）共享锁（S锁）指的都是表锁，意向锁不会与行级的共享锁/排他锁互斥」</strong></p>
<h2 id="七、乐观锁-悲观锁"><a href="#七、乐观锁-悲观锁" class="headerlink" title="七、乐观锁/悲观锁"></a><strong>七、乐观锁/悲观锁</strong></h2><p><strong>「乐观锁/悲观锁其实都是概念上的，只是在并发下防止数据被修改的一种加锁形式」</strong>。</p>
<h3 id="7-1-悲观锁（Pessimistic-Locking）"><a href="#7-1-悲观锁（Pessimistic-Locking）" class="headerlink" title="7.1 悲观锁（Pessimistic Locking）"></a>7.1 悲观锁（Pessimistic Locking）</h3><p><strong>「对数据的修改抱有悲观态度的一种并发控制方式，悲观的认为自己(当前线程)拿到的数据是被修改过的，所以在操作数据之前先加锁」</strong>。</p>
<ul>
<li><p><strong>「悲观锁的形式（类型）」</strong></p>
<p><strong>「数据库的行锁、表锁、读锁、写锁、共享锁、排他锁等，以及syncronized 实现的锁都是悲观锁的范畴」</strong>。</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129096.png" alt="图片"></p>
<ul>
<li><p><strong>「优点」</strong></p>
<p><strong>「可以保证数据的独占性和正确性」</strong>。</p>
</li>
<li><p><strong>「缺点」</strong></p>
<p><strong>「每次请求都需要加锁、释放锁，这个过程会降低系统性能」</strong>。</p>
</li>
</ul>
<h3 id="7-2-乐观锁"><a href="#7-2-乐观锁" class="headerlink" title="7.2 乐观锁"></a>7.2 乐观锁</h3><p><strong>「乐观锁是对于数据冲突保持一种乐观态度，每次读取数据的时都认为其他线程不会修改数据，所以不上锁，只是在数据修改后提交时才通过【版本号机制或者CAS算法】来验证数据是否被其他线程更新」</strong>。</p>
<p>因为乐观锁中并没有【加锁和解锁】操作，因此乐观锁策略也被称为<strong>「无锁编程」</strong>。</p>
<ul>
<li><p><strong>「乐观锁实现的关键点」</strong>：检测冲突</p>
</li>
<li><p><strong>「乐观锁实现方式」</strong></p>
</li>
<li><ul>
<li>版本号机制（常用）</li>
<li>CAS算法实现</li>
</ul>
</li>
<li><p><strong>「优点」</strong></p>
<p><strong>「没有加锁和解锁操作，可以提高吞吐量」</strong></p>
</li>
<li><p><strong>「缺点」</strong></p>
<p>乐观锁需要自己实现，且外部系统不受控制</p>
</li>
<li><p><strong>「乐观锁的应用」</strong></p>
<p>在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS。</p>
</li>
<li><p><strong>「适用场景」</strong>：读多写少</p>
</li>
<li><p><strong>「注意」</strong></p>
<p>乐观锁不是数据库提供的功能，需要开发者自己去实现。</p>
<blockquote>
<p>除了开发者自己手动实现乐观锁之外，很多数据库访问框架也封装了乐观锁的实现</p>
<p>比如 hibernate框架，MyBatis框架的OptimisticLocker插件。</p>
</blockquote>
</li>
</ul>
<h4 id="7-2-1版本号机制实现乐观锁"><a href="#7-2-1版本号机制实现乐观锁" class="headerlink" title="7.2.1版本号机制实现乐观锁"></a>7.2.1版本号机制实现乐观锁</h4><p>版本号机制有两种方式：使用版本字段（version）和使用时间戳（Timestamp），两者实现原理是一样的。</p>
<p>前文中提到<strong>「乐观锁需要开发者自己去实现，所以版本号实现时通过在表中加字段的形式实现的」</strong>。</p>
<ul>
<li><p><strong>「使用版本字段（version）」</strong></p>
<p><strong>「在数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1」</strong>。version 是用来查看被读的记录有无变化，防止记录在业务处理期间被其他事务修改。</p>
</li>
<li><p><strong>「使用时间戳（Timestamp）」</strong></p>
<p>与使用version版本字段基本一致，<strong>「同样需要给在数据表增加一个字段，字段类型使用timestamp时间戳，通过时间戳比较数据版本」</strong>。</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129018.png" alt="图片"></p>
<ul>
<li><p><strong>「乐观锁实现案例」</strong></p>
<p>修改用户表中Id为1的用户姓名</p>
</li>
<li><ul>
<li><p>第一步：查询记录信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">select name,version from user where id&#x3D;1;</span><br><span class="line">#使用时间戳（Timestamp）</span><br><span class="line">select name,timestamp from user where id&#x3D;1;</span><br></pre></td></tr></table></figure></li>
<li><p>第二步：逻辑处理之后，修改姓名为张三</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">update user set name &#x3D; &#39;张三&#39;,version&#x3D;version+1 where id&#x3D;1 and version &#x3D; #&#123;version&#125;;#version 为第一步查询的值</span><br><span class="line"></span><br><span class="line">#使用时间戳（timestamp）</span><br><span class="line">update user set name &#x3D; &#39;张三&#39;,timestamp&#x3D;now() where id&#x3D;1 and timestamp &#x3D; #&#123;timestamp&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-2CAS算法实现乐观锁"><a href="#7-2-2CAS算法实现乐观锁" class="headerlink" title="7.2.2CAS算法实现乐观锁"></a>7.2.2CAS算法实现乐观锁</h4></li>
</ul>
</li>
</ul>
<p><strong>「CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是无锁编程」</strong>。</p>
<ul>
<li><p><strong>「特点」</strong></p>
<p>不加锁，即使没有线程被阻塞的情况下实现变量的同步，也叫非阻塞同步</p>
</li>
<li><p>CAS算法涉及到三个操作数</p>
<p><strong>「当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作」</strong>（比较和替换是一个原子操作），一般情况下是一个自旋操作，即不断的重试。</p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129295.png" alt="图片"></p>
</li>
<li><ul>
<li>变量当前内存值 V</li>
<li>旧的预期值 A</li>
<li>要写入的新值 B</li>
</ul>
</li>
<li><p><strong>「CAS缺点」</strong></p>
</li>
<li><ul>
<li><p><strong>「ABA问题」</strong></p>
<blockquote>
<p>当线程1读到某变量的值为A，在其逻辑处理的过程中，另外一个线程2将该变量的值从A先修改为B、然后又将其从B修改回A。此时，当线程1通过CAS操作进行新值写入虽然可以成功，而实际上线程1执行CAS操作时预期值的A 和读取该变量当前值的A已经不是同一个了，后者是线程2修改的</p>
</blockquote>
</li>
<li><p><strong>「CPU开销大」</strong></p>
<p>虽然CAS算法是非阻塞的，但如果CAS操作一直不成功不断循环，会浪费CPU资源</p>
</li>
<li><p><strong>「只能保证一个共享变量的原子性」</strong></p>
<p>当对多个变量进行操作时，CAS算法无法保证原子性。</p>
<blockquote>
<p>可以将多个变量封装为一个对象再使用CAS算法（Java中的AtomicReference）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="八、死锁和死锁检测"><a href="#八、死锁和死锁检测" class="headerlink" title="八、死锁和死锁检测"></a><strong>八、死锁和死锁检测</strong></h2><h3 id="8-1-死锁是什么"><a href="#8-1-死锁是什么" class="headerlink" title="8.1 死锁是什么"></a>8.1 死锁是什么</h3><p><strong>「死锁是指两个或两个以上的事务在执行过程等中，因争夺资源而造成的一种相互等待的现象」</strong>。</p>
<ul>
<li><p><strong>「死锁产生本质原因」</strong></p>
</li>
<li><ul>
<li>系统资源有限</li>
<li>进程推进顺序不合理</li>
</ul>
</li>
<li><p><strong>「死锁产生的4个必要条件」</strong></p>
</li>
<li><ul>
<li><strong>「互斥条件（Mutual exclusion，简称Mutex）」</strong>资源要么被一个线程占用,要么是可用状态</li>
<li><strong>「不可抢夺（No preemption）」</strong>资源被占用后,除非占有线程主动释放,其他线程不能把它从该线程占用中抢夺</li>
<li><strong>「占有和等待（Hold and wait）」</strong>一个进程必须占有至少一个资源，并等待另一资源，而该资源被其他进程占用</li>
<li><strong>「循环等待（Circular wait）」</strong>一组等待进程{P0, P1…Pn-1, Pn}，P0等待资源被P1占有，P1等待资源被P2占有，Pn-1等待资源被Pn占有，Pn等待资源被P0占有，循环等待，则形成环形结构。</li>
</ul>
</li>
</ul>
<p><strong>「死锁发生的以上四个条件缺一都无法导致死锁，而由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以恢复死锁主要是破坏产生死锁的其他三个条件」</strong>。</p>
<h3 id="8-2-常见死锁现象和解决方案"><a href="#8-2-常见死锁现象和解决方案" class="headerlink" title="8.2 常见死锁现象和解决方案"></a>8.2 常见死锁现象和解决方案</h3><h4 id="8-2-1表级锁死锁"><a href="#8-2-1表级锁死锁" class="headerlink" title="8.2.1表级锁死锁"></a>8.2.1表级锁死锁</h4><ul>
<li><p><strong>「案例」</strong></p>
<p>有线程A、B分别需要访问用户表与订单表，访问表的时候都会加表级锁。线程A访用户表，并对用户表加锁（线程A锁住了用户表），然后又访问订单表；此时线程B先访问订单表，并对订单表加锁（线程B锁住了订单表），然后线程想访问用户表。</p>
</li>
<li><p><strong>「产生原因」</strong></p>
<p>上述案例由于线程B已经锁住订单表，线程A必须等待线程B释放订单表能继续，同样线程B要等线程A释放用户表才能继续，<strong>「线程A、B相互等待对方释放锁，就产生了死锁」</strong>。</p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129385.png" alt="图片"></p>
</li>
<li><p><strong>「解决方案」</strong></p>
<p><strong>「这种死锁是由于程序的BUG产生的，比较常见，只能通过调整程序的逻辑来解决」</strong>。</p>
<blockquote>
<p>对于数据库的多表操作时，尽量按照相同的顺序进行处理，避免同时锁定两个资源，</p>
<p>如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p>
</blockquote>
</li>
</ul>
<h4 id="8-2-2行级锁死锁"><a href="#8-2-2行级锁死锁" class="headerlink" title="8.2.2行级锁死锁"></a>8.2.2行级锁死锁</h4><p>行级锁产生死锁有两种情况，一直是资源争夺，一种是行级锁升级为表级锁</p>
<ul>
<li><p>资源争夺</p>
</li>
<li><ul>
<li><p><strong>「产生原因」</strong></p>
<p>当事务中某个查询没有走索引时，就会走全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），并发下多个线程同时执行，就可能会产生死锁和阻塞</p>
</li>
<li><p><strong>「解决方案」</strong></p>
<p>SQL语句中尽量不要有太复杂的多表关联查询，并通过执行对SQL语句进行分析，建立索引优化，避免全表扫描和全表锁定。</p>
</li>
</ul>
</li>
<li><p>行级锁升级为表级锁</p>
</li>
</ul>
<ul>
<li><ul>
<li><p><strong>「产生原因」</strong></p>
<p>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。</p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129438.png" alt="图片"></p>
</li>
<li><p><strong>「解决方案」</strong></p>
</li>
<li><ul>
<li>在同一个事务中，尽量一次锁定需要的所有资源</li>
<li>将每个资源编号，通过资源编号的线性顺序来预防死锁，当一个进程占有编号为i的资源时，那么它下一次只能申请编号大于i的资源。</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129440.png" alt="图片"></p>
</li>
</ul>
<h4 id="8-2-3共享锁转换为排他锁"><a href="#8-2-3共享锁转换为排他锁" class="headerlink" title="8.2.3共享锁转换为排他锁"></a>8.2.3共享锁转换为排他锁</h4><ul>
<li><p><strong>「案例」</strong></p>
<p>事务A有两个操作，首先查询一条纪录M，然后更新纪录M；此时事务B在事物A查询之后更新之前去更新纪录M，此时事物A获取了记录M的共享锁，事物B获取了记录M的排他锁， 事务B的排他锁由于事务A有共享锁，必须等A释放共享锁后才可以获取，事物B只能排队等待。</p>
</li>
<li><p><strong>「产生原因」</strong></p>
<p>案例中事物B已经进入等待，事物A更新M需要排他锁，而此时事务B已经有一个排他锁请求，并且正在等待事务A释放其共享锁，因此无法给事物A授予排他锁锁请求，事物A也进入排队等待</p>
<blockquote>
<p>注意：这里事物B还没有拿到M的排它锁，只是进入排队等到状态</p>
</blockquote>
</li>
<li><p><strong>「解决方案」</strong></p>
<p>通过<strong>「手动实现乐观锁」</strong>进行控制，乐观锁的无锁机制可以避免长事务中的数据库加锁开销，增大并发量，提升系统性能。</p>
</li>
</ul>
<h3 id="8-3死锁排查"><a href="#8-3死锁排查" class="headerlink" title="8.3死锁排查"></a>8.3死锁排查</h3><p>MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。</p>
<ul>
<li><p><strong>「查看近期死锁日志信息」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129459.png" alt="图片"></p>
<p>通过以上命令查看近期死锁日志信息，然后使用执行计划进行SQL优化</p>
</li>
<li><p><strong>「查看锁状态变量」</strong></p>
<p>通过以下命令可以检查锁状态变量，从而分析系统中的行锁的争夺情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like&#39;innodb_row_lock%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061129485.png" alt="图片"></p>
</li>
<li><ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁的数量</li>
<li>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</li>
<li>Innodb_row_lock_time_avg：每次等待锁的平均时间</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间</li>
<li>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</li>
</ul>
</li>
</ul>
<p><strong>「如果等待次数高，而且每次等待时间长，则需要对其进行分析优化」</strong>。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>MySQL(十三)：小一万字+14张图读懂锁机制</p><p><a href="http://ityouknow.cn/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/">http://ityouknow.cn/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>yunlongn</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Mysql/">Mysql</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/06/MySQL%E5%8D%81%E5%9B%9B%EF%BC%9A%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A72000W%E8%A1%8C%E6%95%B0%E6%8D%AE/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL十四：单表最大2000W行数据</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/06/MySQL%E5%8D%81%E4%BA%8C%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90/"><span class="level-item">MySQL(十二)：索引分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "8b9e05b502cf1a76b101114fce38b484",
            repo: "yunlongn.github.io",
            owner: "yunlongn",
            clientID: "fb8ffef00dff08ccb06c",
            clientSecret: "935a05558f847f4321d3c64b4c0c2498697a2bda",
            admin: "yunlongn",
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="云扬四海"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">云扬四海</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">77</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://github.com/yunlongn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="http://github.com/yunlongn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="cnblogs" href="https://www.cnblogs.com/rolandlee/"><i class="fas fa-book"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="tagscloud" style="transition: opacity 0.3s ease-out 0s, transform 0.3s ease-out 0s; opacity: 1; transform-origin: center top;"><div class="card-content" id="tags"><h3 class="menu-label">标签云</h3><a href="/tags/JVM/" style="color:rgb(168,127,150);font-size:19px">JVM<span class="tag-cloud-count">(1) </span></a><a href="/tags/Java/" style="color:rgb(173,135,121);font-size:18px">Java<span class="tag-cloud-count">(5) </span></a><a href="/tags/Mysql/" style="color:rgb(183,170,110);font-size:22px">Mysql<span class="tag-cloud-count">(18) </span></a><a href="/tags/Netty/" style="color:rgb(184,135,119);font-size:13px">Netty<span class="tag-cloud-count">(1) </span></a><a href="/tags/Nginx/" style="color:rgb(169,142,127);font-size:22px">Nginx<span class="tag-cloud-count">(1) </span></a><a href="/tags/SpringBoot/" style="color:rgb(152,108,115);font-size:18px">SpringBoot<span class="tag-cloud-count">(2) </span></a><a href="/tags/heroku/" style="color:rgb(165,104,153);font-size:14px">heroku<span class="tag-cloud-count">(1) </span></a><a href="/tags/java/" style="color:rgb(176,147,121);font-size:21px">java<span class="tag-cloud-count">(1) </span></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="color:rgb(146,151,111);font-size:21px">java基础<span class="tag-cloud-count">(2) </span></a><a href="/tags/java%E6%A0%B8%E5%BF%83/" style="color:rgb(153,127,139);font-size:17px">java核心<span class="tag-cloud-count">(1) </span></a><a href="/tags/linux/" style="color:rgb(184,145,120);font-size:22px">linux<span class="tag-cloud-count">(1) </span></a><a href="/tags/mq/" style="color:rgb(145,162,124);font-size:16px">mq<span class="tag-cloud-count">(1) </span></a><a href="/tags/mybatisPlus/" style="color:rgb(161,150,103);font-size:15px">mybatisPlus<span class="tag-cloud-count">(1) </span></a><a href="/tags/nio/" style="color:rgb(131,108,128);font-size:17px">nio<span class="tag-cloud-count">(1) </span></a><a href="/tags/servlet/" style="color:rgb(190,104,135);font-size:22px">servlet<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="color:rgb(202,155,104);font-size:22px">事务<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="color:rgb(186,114,114);font-size:13px">信号量<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="color:rgb(166,138,85);font-size:21px">分布式事务<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/" style="color:rgb(197,166,125);font-size:17px">图片识别<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" style="color:rgb(141,151,129);font-size:22px">基本命令<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="color:rgb(171,122,109);font-size:15px">小程序<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="color:rgb(185,131,133);font-size:18px">工具<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E6%80%A7%E8%83%BD/" style="color:rgb(180,157,144);font-size:14px">性能<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E6%8A%80%E5%B7%A7/" style="color:rgb(198,131,152);font-size:19px">技巧<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E7%AD%BE%E5%90%8D/" style="color:rgb(159,132,154);font-size:14px">签名<span class="tag-cloud-count">(2) </span></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="color:rgb(149,148,121);font-size:15px">设计模式<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="color:rgb(203,105,80);font-size:17px">读书笔记<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E9%98%B2%E7%9B%97%E9%93%BE/" style="color:rgb(144,130,113);font-size:13px">防盗链<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="color:rgb(134,169,105);font-size:14px">面试<span class="tag-cloud-count">(1) </span></a></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://www.ityouknow.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">纯洁的微笑</span></span><span class="level-right"><span class="level-item tag">www.ityouknow.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.52itstyle.vip/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">柒&#039;s</span></span><span class="level-right"><span class="level-item tag">blog.52itstyle.vip</span></span></a></li><li><a class="level is-mobile" href="https://www.wdk.pw/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">王登科</span></span><span class="level-right"><span class="level-item tag">www.wdk.pw</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><embed src="/img/footer.svg" id="galinv" type="image/svg+xml"><footer class="footer"><div class="footer-image"><img src="/img/o_cnblogs_footer.png" width="60%"></div><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">云扬四海</a><p class="is-size-7"><span>&copy; 2022 yunlongn</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yunlongn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>