<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java 设计模式 - 云扬四海</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="云扬四海"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="云扬四海"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结 设计模式分为 23 种经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式 列举几种设计原则，这几种设计原则将贯通全文：  面向接口编程，而不是面向实现。这个尤为重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧    职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来"><meta property="og:type" content="blog"><meta property="og:title" content="Java 设计模式"><meta property="og:url" content="http://ityouknow.cn/2019/05/20/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="云扬四海"><meta property="og:description" content="设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结 设计模式分为 23 种经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式 列举几种设计原则，这几种设计原则将贯通全文：  面向接口编程，而不是面向实现。这个尤为重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧    职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520143952.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144103.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144237.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144258.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520150626.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151032.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151119.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151335.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151512.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151615.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151958.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152042.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152640.png"><meta property="og:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152702.png"><meta property="article:published_time" content="2019-05-20T01:50:00.000Z"><meta property="article:modified_time" content="2021-02-21T03:01:53.000Z"><meta property="article:author" content="RolandLee"><meta property="article:tag" content="设计模式"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520143952.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ityouknow.cn/2019/05/20/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},"headline":"云扬四海","image":["https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520143952.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144103.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144237.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144258.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520150626.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151032.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151119.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151335.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151512.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151615.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151958.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152042.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152640.png","https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152702.png"],"datePublished":"2019-05-20T01:50:00.000Z","dateModified":"2021-02-21T03:01:53.000Z","author":{"@type":"Person","name":"RolandLee"},"description":"设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结 设计模式分为 23 种经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式 列举几种设计原则，这几种设计原则将贯通全文：  面向接口编程，而不是面向实现。这个尤为重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧    职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来"}</script><link rel="canonical" href="http://ityouknow.cn/2019/05/20/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.8.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">云扬四海</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">列表</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/yun/fireworks.html">fireworks</a><a class="navbar-item" href="/yun/sheep.html">sheep</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="http://github.com/yunlongn"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-20T01:50:00.000Z" title="2019-05-20T01:50:00.000Z">2019-05-20</time>发表</span><span class="level-item"><time dateTime="2021-02-21T03:01:53.000Z" title="2021-02-21T03:01:53.000Z">2021-02-21</time>更新</span><span class="level-item"> RolandLee </span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">1 小时读完 (大约12246个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java 设计模式</h1><div class="content"><h4 id="设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结"><a href="#设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结" class="headerlink" title="设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结"></a>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结</h4><ul>
<li>设计模式分为 <strong>23 种</strong>经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式</li>
<li>列举几种设计原则，这几种设计原则将贯通全文：</li>
<li><ul>
<li>面向接口编程，而不是面向实现。这个尤为重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧</li>
</ul>
</li>
<li><ul>
<li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来</li>
</ul>
</li>
<li><ul>
<li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li>创建型模式的作用就是创建对象，new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>和名字一样简单，非常简单，直接上代码吧：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;noodle&quot;)) &#123;</span><br><span class="line">            Food noodle &#x3D; new LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(&quot;more&quot;);</span><br><span class="line">            return noodle;</span><br><span class="line">        &#125; else if (name.equals(&quot;chicken&quot;)) &#123;</span><br><span class="line">            Food chicken &#x3D; new HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(&quot;potato&quot;);</span><br><span class="line">            return chicken;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</li>
<li>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</li>
</ul>
<blockquote>
<p>我们强调职责单一原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface FoodFactory &#123;</span><br><span class="line">    Food makeFood(String name);</span><br><span class="line">&#125;</span><br><span class="line">public class ChineseFoodFactory implements FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            return new ChineseFoodA();</span><br><span class="line">        &#125; else if (name.equals(&quot;B&quot;)) &#123;</span><br><span class="line">            return new ChineseFoodB();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AmericanFoodFactory implements FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            return new AmericanFoodA();</span><br><span class="line">        &#125; else if (name.equals(&quot;B&quot;)) &#123;</span><br><span class="line">            return new AmericanFoodB();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
</li>
<li><p>客户端调用：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class APP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先选择一个具体的工厂</span><br><span class="line">        FoodFactory factory &#x3D; new ChineseFoodFactory();</span><br><span class="line">        &#x2F;&#x2F; 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span><br><span class="line">        Food food &#x3D; factory.makeFood(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>虽然都是调用 makeFood(“A”) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
</li>
<li><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
</li>
<li><p><strong>核心在于，我们需要在第一步选好我们需要的工厂。</strong>比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
</li>
<li><p>虽然简单，不过我也把所有的构件都画到一张图上，这样看着比较清晰：</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520143952.png"></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>当涉及到产品族的时候，就需要引入抽象工厂模式了。</li>
<li>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</li>
<li>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144103.png"></p>
<ul>
<li>这个时候的客户端调用是这样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到 Intel 的 CPU</span><br><span class="line">CPUFactory cpuFactory &#x3D; new IntelCPUFactory();</span><br><span class="line">CPU cpu &#x3D; intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到 AMD 的主板</span><br><span class="line">MainBoardFactory mainBoardFactory &#x3D; new AmdMainBoardFactory();</span><br><span class="line">MainBoard mainBoard &#x3D; mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组装 CPU 和主板</span><br><span class="line">Computer computer &#x3D; new Computer(cpu, mainBoard);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>
</li>
<li><p>但是，这种方式有一个问题，那就是如果** Intel 家产的 CPU 和 AMD 产的主板不能兼容使用**，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
</li>
</ul>
<p>-下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合： </p>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144237.png"></p>
<ul>
<li>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144258.png"></p>
<ul>
<li>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步就要选定一个“大厂”</span><br><span class="line">    ComputerFactory cf &#x3D; new AmdFactory();</span><br><span class="line">    &#x2F;&#x2F; 从这个大厂造 CPU</span><br><span class="line">    CPU cpu &#x3D; cf.makeCPU();</span><br><span class="line">    &#x2F;&#x2F; 从这个大厂造主板</span><br><span class="line">    MainBoard board &#x3D; cf.makeMainBoard();</span><br><span class="line">      &#x2F;&#x2F; 从这个大厂造硬盘</span><br><span class="line">      HardDisk hardDisk &#x3D; cf.makeHardDisk();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span><br><span class="line">    Computer result &#x3D; new Computer(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了对<strong>修改关闭，对扩展开放</strong>这个设计原则。</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>单例模式用得最多，错得最多。</p>
</li>
<li><p>饿汉模式最简单：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先，将 new Singleton() 堵死</span><br><span class="line">    private Singleton() &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span><br><span class="line">    private static Singleton instance &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span><br><span class="line">    &#x2F;&#x2F; 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span><br><span class="line">    public static Date getDate(String mode) &#123;return new Date();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>
</blockquote>
<ul>
<li>饱汉模式最容易出错：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先，也是先堵死 new Singleton() 这条路</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    &#x2F;&#x2F; 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span><br><span class="line">    private static volatile Singleton instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 加锁</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这一次判断也是必须的，不然会有并发问题</span><br><span class="line">                if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    instance &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。<br>volatile 在这里是需要的，希望能引起读者的关注。<br>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<ul>
<li>嵌套类最经典，以后大家就用它吧：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton3() &#123;&#125;</span><br><span class="line">    &#x2F;&#x2F; 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span><br><span class="line">    private static class Holder &#123;</span><br><span class="line">        private static Singleton3 instance &#x3D; new Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        return Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<ul>
<li>最后，一定有人跳出来说用枚举实现单例，是的没错，枚举类很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。不说了，读者自己看着办吧，不建议使用。</li>
</ul>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul>
<li>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Food food &#x3D; new FoodBuilder().a().b().c().build();</span><br><span class="line">Food food &#x3D; Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>
</li>
<li><p>来一个中规中矩的建造者模式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    &#x2F;&#x2F; 下面是“一堆”的属性</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private String nickName;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造方法私有化，不然客户端就会直接调用构造方法了</span><br><span class="line">    private User(String name, String password, String nickName, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span><br><span class="line">    &#x2F;&#x2F; 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span><br><span class="line">    public static UserBuilder builder() &#123;</span><br><span class="line">        return new UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class UserBuilder &#123;</span><br><span class="line">        &#x2F;&#x2F; 下面是和 User 一模一样的一堆属性</span><br><span class="line">        private String  name;</span><br><span class="line">        private String password;</span><br><span class="line">        private String nickName;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        private UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 链式调用设置各个属性值，返回 this，即 UserBuilder</span><br><span class="line">        public UserBuilder name(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder password(String password) &#123;</span><br><span class="line">            this.password &#x3D; password;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder nickName(String nickName) &#123;</span><br><span class="line">            this.nickName &#x3D; nickName;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder age(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span><br><span class="line">        &#x2F;&#x2F; 当然，可以在 “复制” 之前做点检验</span><br><span class="line">        public User build() &#123;</span><br><span class="line">            if (name &#x3D;&#x3D; null || password &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;用户名和密码必填&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (age &lt;&#x3D; 0 || age &gt;&#x3D; 150) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;年龄不合法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 还可以做赋予”默认值“的功能</span><br><span class="line">              if (nickName &#x3D;&#x3D; null) &#123;</span><br><span class="line">                nickName &#x3D; name;</span><br><span class="line">            &#125;</span><br><span class="line">            return new User(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性复制给实际产生的对象。</p>
</li>
<li><p>看看客户端的调用：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class APP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User d &#x3D; User.builder()</span><br><span class="line">                .name(&quot;foo&quot;)</span><br><span class="line">                .password(&quot;pAss12345&quot;)</span><br><span class="line">                .age(25)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>说实话，建造者模式的链式写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</li>
</ul>
<blockquote>
<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Builder</span><br><span class="line">class User &#123;</span><br><span class="line">    private String  name;</span><br><span class="line">    private String password;</span><br><span class="line">    private String nickName;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
<ul>
<li>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 *<strong>return this</strong> 就可以了，然后就可以像下面这样调用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new User().setName(&quot;&quot;).setPassword(&quot;&quot;).setAge(20);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><ul>
<li>这是我要说的创建型模式的最后一个设计模式了。</li>
<li>原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。</li>
<li>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先实现 Cloneable 接口，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
</blockquote>
<ul>
<li>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</li>
</ul>
<h2 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h2><ul>
<li><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。</p>
</li>
<li><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>
</li>
</ul>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><ul>
<li>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>
</li>
<li><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>
</li>
</ul>
<blockquote>
<p>理解代理这个词，这个模式其实就简单了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface FoodService &#123;</span><br><span class="line">    Food makeChicken();</span><br><span class="line">    Food makeNoodle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FoodServiceImpl implements FoodService &#123;</span><br><span class="line">    public Food makeChicken() &#123;</span><br><span class="line">          Food f &#x3D; new Chicken()</span><br><span class="line">        f.setChicken(&quot;1kg&quot;);</span><br><span class="line">          f.setSpicy(&quot;1g&quot;);</span><br><span class="line">          f.setSalt(&quot;3g&quot;);</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">    public Food makeNoodle() &#123;</span><br><span class="line">        Food f &#x3D; new Noodle();</span><br><span class="line">        f.setNoodle(&quot;500g&quot;);</span><br><span class="line">        f.setSalt(&quot;5g&quot;);</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span><br><span class="line">public class FoodServiceProxy implements FoodService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span><br><span class="line">    private FoodService foodService &#x3D; new FoodServiceImpl();</span><br><span class="line"></span><br><span class="line">    public Food makeChicken() &#123;</span><br><span class="line">        System.out.println(&quot;我们马上要开始制作鸡肉了&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span><br><span class="line">        &#x2F;&#x2F; 代理只是在核心代码前后做些“无足轻重”的事情</span><br><span class="line">        Food food &#x3D; foodService.makeChicken();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;); &#x2F;&#x2F; 增强</span><br><span class="line">          food.addCondiment(&quot;pepper&quot;);</span><br><span class="line"></span><br><span class="line">        return food;</span><br><span class="line">    &#125;</span><br><span class="line">    public Food makeNoodle() &#123;</span><br><span class="line">        System.out.println(&quot;准备制作拉面~&quot;);</span><br><span class="line">        Food food &#x3D; foodService.makeNoodle();</span><br><span class="line">        System.out.println(&quot;制作完成啦&quot;)</span><br><span class="line">        return food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端调用，注意，我们要用代理来实例化接口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里用代理类来实例化</span><br><span class="line">FoodService foodService &#x3D; new FoodServiceProxy();</span><br><span class="line">foodService.makeChicken();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520150626.png"></p>
<ul>
<li>我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</li>
</ul>
<ul>
<li>说到动态代理，又可以展开说 …… Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul>
<li>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</li>
<li>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配</li>
<li>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</li>
</ul>
<h3 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h3><ul>
<li>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</li>
<li>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface FileAlterationListener &#123;</span><br><span class="line">    void onStart(final FileAlterationObserver observer);</span><br><span class="line">    void onDirectoryCreate(final File directory);</span><br><span class="line">    void onDirectoryChange(final File directory);</span><br><span class="line">    void onDirectoryDelete(final File directory);</span><br><span class="line">    void onFileCreate(final File file);</span><br><span class="line">    void onFileChange(final File file);</span><br><span class="line">    void onFileDelete(final File file);</span><br><span class="line">    void onStop(final FileAlterationObserver observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>
</li>
<li><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是所有的方法都是空方法，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FileAlterationListenerAdaptor implements FileAlterationListener &#123;</span><br><span class="line"></span><br><span class="line">    public void onStart(final FileAlterationObserver observer) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onDirectoryCreate(final File directory) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onDirectoryChange(final File directory) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onDirectoryDelete(final File directory) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onFileCreate(final File file) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onFileChange(final File file) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onFileDelete(final File file) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onStop(final FileAlterationObserver observer) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FileMonitor extends FileAlterationListenerAdaptor &#123;</span><br><span class="line">    public void onFileCreate(final File file) &#123;</span><br><span class="line">        &#x2F;&#x2F; 文件创建</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onFileDelete(final File file) &#123;</span><br><span class="line">        &#x2F;&#x2F; 文件删除</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍“正统的”适配器模式。</li>
</ul>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><ul>
<li>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Duck &#123;</span><br><span class="line">    public void quack(); &#x2F;&#x2F; 鸭的呱呱叫</span><br><span class="line">      public void fly(); &#x2F;&#x2F; 飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Cock &#123;</span><br><span class="line">    public void gobble(); &#x2F;&#x2F; 鸡的咕咕叫</span><br><span class="line">      public void fly(); &#x2F;&#x2F; 飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WildCock implements Cock &#123;</span><br><span class="line">    public void gobble() &#123;</span><br><span class="line">        System.out.println(&quot;咕咕叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;鸡也会飞哦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span><br><span class="line">public class CockAdapter implements Duck &#123;</span><br><span class="line"></span><br><span class="line">    Cock cock;</span><br><span class="line">    &#x2F;&#x2F; 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span><br><span class="line">      public CockAdapter(Cock cock) &#123;</span><br><span class="line">        this.cock &#x3D; cock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现鸭的呱呱叫方法</span><br><span class="line">      @Override</span><br><span class="line">      public void quack() &#123;</span><br><span class="line">        &#x2F;&#x2F; 内部其实是一只鸡的咕咕叫</span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void fly() &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端调用很简单了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 有一只野鸡</span><br><span class="line">      Cock wildCock &#x3D; new WildCock();</span><br><span class="line">      &#x2F;&#x2F; 成功将野鸡适配成鸭</span><br><span class="line">      Duck duck &#x3D; new CockAdapter(wildCock);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>
</li>
<li><p>我们用一个图来简单说明下：</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151032.png"></p>
<ul>
<li>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</li>
</ul>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><ul>
<li>废话少说，直接上图：</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151119.png"></p>
<ul>
<li>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <strong>Target t = new SomeAdapter();</strong> 就可以了。</li>
</ul>
<h3 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h3><ul>
<li><p>类适配和对象适配的异同</p>
</li>
<li><ul>
<li><blockquote>
<p>一个采用继承，一个采用组合；</p>
</blockquote>
</li>
</ul>
</li>
<li><ul>
<li><blockquote>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
</blockquote>
</li>
</ul>
</li>
<li><ul>
<li><blockquote>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>适配器模式和代理模式的异同</p>
</li>
<li><ul>
<li>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</li>
</ul>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151335.png"></p>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><ul>
<li><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p>
</li>
<li><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DrawAPI &#123;</span><br><span class="line">   public void draw(int radius, int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后是一系列实现类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedPen implements DrawAPI &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GreenPen implements DrawAPI &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BluePen implements DrawAPI &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape &#123;</span><br><span class="line">   protected DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">   protected Shape(DrawAPI drawAPI)&#123;</span><br><span class="line">      this.drawAPI &#x3D; drawAPI;</span><br><span class="line">   &#125;</span><br><span class="line">   public abstract void draw();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义抽象类的子类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 圆形</span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">   private int radius;</span><br><span class="line"></span><br><span class="line">   public Circle(int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">      super(drawAPI);</span><br><span class="line">      this.radius &#x3D; radius;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      drawAPI.draw(radius, 0, 0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 长方形</span><br><span class="line">public class Rectangle extends Shape &#123;</span><br><span class="line">    private int x;</span><br><span class="line">      private int y;</span><br><span class="line"></span><br><span class="line">      public Rectangle(int x, int y, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">          this.x &#x3D; x;</span><br><span class="line">          this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">      public void draw() &#123;</span><br><span class="line">      drawAPI.draw(0, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>最后，我们来看客户端演示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Shape greenCircle &#x3D; new Circle(10, new GreenPen());</span><br><span class="line">      Shape redRectangle &#x3D; new Rectangle(4, 8, new RedPen());</span><br><span class="line"></span><br><span class="line">      greenCircle.draw();</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151512.png"></p>
<ul>
<li>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</li>
</ul>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ul>
<li><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
</li>
<li><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151615.png"></p>
<ul>
<li>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component </code>其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</li>
</ul>
<blockquote>
<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的方式，但是那样的话代码就复杂了。</p>
</blockquote>
<ul>
<li><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 ConcreteDecorator</p>
</li>
<li><p>都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起装饰作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰而已。</strong></p>
</li>
</ul>
<blockquote>
<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>
</blockquote>
<ul>
<li><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>
</li>
<li><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
</li>
<li><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？万一有个变态要四份柠檬，所以这种做法是给自己找加班的。</p>
</li>
<li><p>不说废话了，上代码。</p>
</li>
<li><p>首先，定义饮料抽象基类：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Beverage &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回描述</span><br><span class="line">      public abstract String getDescription();</span><br><span class="line">      &#x2F;&#x2F; 返回价格</span><br><span class="line">      public abstract double cost();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BlackTea extends Beverage &#123;</span><br><span class="line">      public String getDescription() &#123;</span><br><span class="line">        return &quot;红茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GreenTea extends Beverage &#123;</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;绿茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        return 11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...&#x2F;&#x2F; 咖啡省略</span><br></pre></td></tr></table></figure>
<ul>
<li>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调料</span><br><span class="line">public abstract class Condiment extends Beverage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承 Condiment 类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Lemon extends Condiment &#123;</span><br><span class="line">    private Beverage bevarage;</span><br><span class="line">      &#x2F;&#x2F; 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span><br><span class="line">      &#x2F;&#x2F; 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span><br><span class="line">      public Lemon(Beverage bevarage) &#123;</span><br><span class="line">        this.bevarage &#x3D; bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">      public String getDescription() &#123;</span><br><span class="line">        &#x2F;&#x2F; 装饰</span><br><span class="line">        return bevarage.getDescription() + &quot;, 加柠檬&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">          &#x2F;&#x2F; 装饰</span><br><span class="line">        return beverage.cost() + 2; &#x2F;&#x2F; 加柠檬需要 2 元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Mango extends Condiment &#123;</span><br><span class="line">    private Beverage bevarage;</span><br><span class="line">      public Mango(Beverage bevarage) &#123;</span><br><span class="line">        this.bevarage &#x3D; bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">      public String getDescription() &#123;</span><br><span class="line">        return bevarage.getDescription() + &quot;, 加芒果&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        return beverage.cost() + 3; &#x2F;&#x2F; 加芒果需要 3 元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...&#x2F;&#x2F; 给每一种调料都加一个类</span><br></pre></td></tr></table></figure>
<ul>
<li>看客户端调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span><br><span class="line">    Beverage beverage &#x3D; new GreenTea();</span><br><span class="line">      &#x2F;&#x2F; 开始装饰</span><br><span class="line">      beverage &#x3D; new Lemon(beverage); &#x2F;&#x2F; 先加一份柠檬</span><br><span class="line">      beverage &#x3D; new Mongo(beverage); &#x2F;&#x2F; 再加一份芒果</span><br><span class="line"></span><br><span class="line">      System.out.println(beverage.getDescription() + &quot; 价格：￥&quot; + beverage.cost());</span><br><span class="line">      &#x2F;&#x2F;&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果我们需要芒果珍珠双份柠檬红茶：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage &#x3D; new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>是不是很变态？</p>
</li>
<li><p>看看下图可能会清晰一些：</p>
</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151958.png"></p>
<ul>
<li>到这里，大家应该已经清楚装饰模式了吧。</li>
<li>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152042.png"></p>
<ul>
<li><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
</li>
<li><p>FilterInputStream 承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
</li>
<li><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream &#x3D; new LineNumberInputStream(new BufferedInputStream(new FileInputStream(&quot;&quot;)));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>
</li>
<li><p>我们应该像下面这样使用：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream is &#x3D; new DataInputStream(</span><br><span class="line">                              new BufferedInputStream(</span><br><span class="line">                                  new FileInputStream(&quot;&quot;)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的</p>
</blockquote>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><ul>
<li><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p>
</li>
<li><p>首先，我们定义一个接口：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义几个实现类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Circle::draw()&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端调用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 画一个圆形</span><br><span class="line">      Shape circle &#x3D; new Circle();</span><br><span class="line">      circle.draw();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 画一个长方形</span><br><span class="line">      Shape rectangle &#x3D; new Rectangle();</span><br><span class="line">      rectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p>
</li>
<li><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p>
</li>
<li><p>我们先定义一个门面：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeMaker &#123;</span><br><span class="line">   private Shape circle;</span><br><span class="line">   private Shape rectangle;</span><br><span class="line">   private Shape square;</span><br><span class="line"></span><br><span class="line">   public ShapeMaker() &#123;</span><br><span class="line">      circle &#x3D; new Circle();</span><br><span class="line">      rectangle &#x3D; new Rectangle();</span><br><span class="line">      square &#x3D; new Square();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">   public void drawCircle()&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   public void drawRectangle()&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   public void drawSquare()&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>看看现在客户端怎么调用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ShapeMaker shapeMaker &#x3D; new ShapeMaker();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 客户端调用现在更加清晰了</span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</li>
</ul>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ul>
<li>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</li>
<li>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String dept;</span><br><span class="line">   private int salary;</span><br><span class="line">   private List&lt;Employee&gt; subordinates; &#x2F;&#x2F; 下属</span><br><span class="line"></span><br><span class="line">   public Employee(String name,String dept, int sal) &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      this.dept &#x3D; dept;</span><br><span class="line">      this.salary &#x3D; sal;</span><br><span class="line">      subordinates &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void add(Employee e) &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void remove(Employee e) &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</span><br><span class="line">     return subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return (&quot;Employee :[ Name : &quot; + name + &quot;, dept : &quot; + dept + &quot;, salary :&quot; + salary+&quot; ]&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</li>
</ul>
<ul>
<li>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</li>
</ul>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ul>
<li><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p>
</li>
<li><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p>
</li>
<li><p>这种简单的代码我就不演示了。</p>
</li>
</ul>
<h2 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h2><ul>
<li>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</li>
</ul>
<ul>
<li>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</li>
</ul>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><ul>
<li>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul>
<li><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p>
</li>
<li><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p>
</li>
<li><p>首先，先定义一个策略接口：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public void draw(int radius, int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们定义具体的几个策略：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class RedPen implements Strategy &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GreenPen implements Strategy &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BluePen implements Strategy &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void draw(int radius, int x, int y) &#123;</span><br><span class="line">      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用策略的类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">   private Strategy strategy;</span><br><span class="line"></span><br><span class="line">   public Context(Strategy strategy)&#123;</span><br><span class="line">      this.strategy &#x3D; strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int executeDraw(int radius, int x, int y)&#123;</span><br><span class="line">      return strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端演示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Context context &#x3D; new Context(new BluePen()); &#x2F;&#x2F; 使用绿色笔来画</span><br><span class="line">      context.executeDraw(10, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>放到一张图上，让大家看得清晰些：</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152640.png"></p>
<ul>
<li>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</li>
</ul>
<p><img src="https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152702.png"></p>
<ul>
<li>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</li>
</ul>
<ul>
<li>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">   private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();</span><br><span class="line">   private int state;</span><br><span class="line"></span><br><span class="line">   public int getState() &#123;</span><br><span class="line">      return state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setState(int state) &#123;</span><br><span class="line">      this.state &#x3D; state;</span><br><span class="line">      &#x2F;&#x2F; 数据已变更，通知观察者们</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void attach(Observer observer)&#123;</span><br><span class="line">      observers.add(observer);        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 通知观察者们</span><br><span class="line">   public void notifyAllObservers()&#123;</span><br><span class="line">      for (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义观察者接口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;</span><br><span class="line">   protected Subject subject;</span><br><span class="line">   public abstract void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p>
</li>
<li><p>我们来定义具体的几个观察者类：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryObserver extends Observer &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 在构造方法中进行订阅主题</span><br><span class="line">    public BinaryObserver(Subject subject) &#123;</span><br><span class="line">        this.subject &#x3D; subject;</span><br><span class="line">        &#x2F;&#x2F; 通常在构造方法中将 this 发布出去的操作一定要小心</span><br><span class="line">        this.subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 该方法由主题类在数据变更的时候进行调用</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        String result &#x3D; Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HexaObserver extends Observer &#123;</span><br><span class="line"></span><br><span class="line">    public HexaObserver(Subject subject) &#123;</span><br><span class="line">        this.subject &#x3D; subject;</span><br><span class="line">        this.subject.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">          String result &#x3D; Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端使用也非常简单：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先定义一个主题</span><br><span class="line">      Subject subject1 &#x3D; new Subject();</span><br><span class="line">      &#x2F;&#x2F; 定义观察者</span><br><span class="line">      new BinaryObserver(subject1);</span><br><span class="line">      new HexaObserver(subject1);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span><br><span class="line">      subject.setState(11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p>
</li>
<li><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p>
</li>
</ul>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul>
<li><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了</p>
</li>
<li><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p>
</li>
</ul>
<blockquote>
<p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p>
</blockquote>
<ul>
<li>首先，我们要定义流程上节点的基类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RuleHandler &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 后继节点</span><br><span class="line">    protected RuleHandler successor;</span><br><span class="line"></span><br><span class="line">    public abstract void apply(Context context);</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(RuleHandler successor) &#123;</span><br><span class="line">        this.successor &#x3D; successor;</span><br><span class="line">    &#125;</span><br><span class="line">    public RuleHandler getSuccessor() &#123;</span><br><span class="line">        return successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来，我们需要定义具体的每个节点了。</p>
</li>
<li><p>校验用户是否是新用户：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class NewUserRuleHandler extends RuleHandler &#123;</span><br><span class="line"></span><br><span class="line">    public void apply(Context context) &#123;</span><br><span class="line">        if (context.isNewUser()) &#123;</span><br><span class="line">              &#x2F;&#x2F; 如果有后继节点的话，传递下去</span><br><span class="line">            if (this.getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">                this.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;该活动仅限新用户参与&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>校验用户所在地区是否可以参与：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LocationRuleHandler extends RuleHandler &#123;</span><br><span class="line">    public void apply(Context context) &#123;</span><br><span class="line">        boolean allowed &#x3D; activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">          if (allowed) &#123;</span><br><span class="line">            if (this.getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">                this.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else  &#123;</span><br><span class="line">            throw new RuntimeException(&quot;非常抱歉，您所在的地区无法参与本次活动&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>校验奖品是否已领完：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LimitRuleHandler extends RuleHandler &#123;</span><br><span class="line">    public void apply(Context context) &#123;</span><br><span class="line">          int remainedTimes &#x3D; activityService.queryRemainedTimes(context); &#x2F;&#x2F; 查询剩余奖品</span><br><span class="line">        if (remainedTimes &gt; 0) &#123;</span><br><span class="line">            if (this.getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">                this.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;您来得太晚了，奖品被领完了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    RuleHandler newUserHandler &#x3D; new NewUserRuleHandler();</span><br><span class="line">      RuleHandler locationHandler &#x3D; new LocationRuleHandler();</span><br><span class="line">      RuleHandler limitHandler &#x3D; new LimitRuleHandler();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 假设本次活动仅校验地区和奖品数量，不校验新老用户</span><br><span class="line">      locationHandler.setSuccessor(limitHandler);</span><br><span class="line">      locationHandler.apply(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p>
</li>
<li><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>
</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul>
<li><p>在含有继承结构的代码中，模板方法模式是非常常用的，这也是在开源代码中大量被使用的。</p>
</li>
<li><p>通常会有一个抽象类：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractTemplate &#123;</span><br><span class="line">    &#x2F;&#x2F; 这就是模板方法</span><br><span class="line">      public void templateMethod()&#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); &#x2F;&#x2F; 这个是重点</span><br><span class="line">        end(); &#x2F;&#x2F; 可以作为钩子方法</span><br><span class="line">    &#125;</span><br><span class="line">    protected void init() &#123;</span><br><span class="line">        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      &#x2F;&#x2F; 留给子类实现</span><br><span class="line">    protected abstract void apply();</span><br><span class="line">    protected void end() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</li>
<li>我们写一个实现类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTemplate extends AbstractTemplate &#123;</span><br><span class="line">    public void apply() &#123;</span><br><span class="line">        System.out.println(&quot;子类实现抽象方法 apply&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      public void end() &#123;</span><br><span class="line">        System.out.println(&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端调用演示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AbstractTemplate t &#x3D; new ConcreteTemplate();</span><br><span class="line">      &#x2F;&#x2F; 调用模板方法</span><br><span class="line">      t.templateMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ul>
<li><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p>
</li>
<li><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p>
</li>
<li><p>定义状态接口：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">   public void doAction(Context context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义减库存的状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DeductState implements State &#123;</span><br><span class="line"></span><br><span class="line">   public void doAction(Context context) &#123;</span><br><span class="line">      System.out.println(&quot;商品卖出，准备减库存&quot;);</span><br><span class="line">      context.setState(this);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;... 执行减库存的具体操作</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return &quot;Deduct State&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>定义补库存状态：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RevertState implements State &#123;</span><br><span class="line">    public void doAction(Context context) &#123;</span><br><span class="line">        System.out.println(&quot;给此商品补库存&quot;);</span><br><span class="line">          context.setState(this);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;... 执行加库存的具体操作</span><br><span class="line">    &#125;</span><br><span class="line">      public String toString() &#123;</span><br><span class="line">        return &quot;Revert State&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private State state;</span><br><span class="line">      private String name;</span><br><span class="line">      public Context(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      public void setState(State state) &#123;</span><br><span class="line">        this.state &#x3D; state;</span><br><span class="line">    &#125;</span><br><span class="line">      public void getState() &#123;</span><br><span class="line">        return this.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>我们来看下客户端调用，大家就一清二楚了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 我们需要操作的是 iPhone X</span><br><span class="line">    Context context &#x3D; new Context(&quot;iPhone X&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 看看怎么进行补库存操作</span><br><span class="line">      State revertState &#x3D; new RevertState();</span><br><span class="line">      revertState.doAction(context);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同样的，减库存操作也非常简单</span><br><span class="line">      State deductState &#x3D; new DeductState();</span><br><span class="line">      deductState.doAction(context);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果需要我们可以获取当前的状态</span><br><span class="line">    &#x2F;&#x2F; context.getState().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</li>
<li>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</li>
</ul>
<h2 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h2><ul>
<li>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java 设计模式</p><p><a href="http://ityouknow.cn/2019/05/20/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://ityouknow.cn/2019/05/20/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>RolandLee</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-05-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/05/20/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">拦截器和过滤器的区别</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/05/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span class="level-item">Java集合框架</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "aa17ca057b9175b862b7526546114ace",
            repo: "yunlongn.github.io",
            owner: "yunlongn",
            clientID: "fb8ffef00dff08ccb06c",
            clientSecret: "935a05558f847f4321d3c64b4c0c2498697a2bda",
            admin: "yunlongn",
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="云扬四海"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">云扬四海</p><p class="is-size-6 is-block">云扬四海</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广东 河源</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">28</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://github.com/yunlongn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="http://github.com/yunlongn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="cnblogs" href="https://www.cnblogs.com/rolandlee/"><i class="fas fa-book"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tagscloud" style="transition: opacity 0.3s ease-out 0s, transform 0.3s ease-out 0s; opacity: 1; transform-origin: center top;"><div class="card-content" id="tags"><h3 class="menu-label">标签云</h3><a href="/tags/JVM/" style="color:rgb(142,174,150);font-size:16px">JVM<span class="tag-cloud-count">(1) </span></a><a href="/tags/Java/" style="color:rgb(149,157,138);font-size:21px">Java<span class="tag-cloud-count">(4) </span></a><a href="/tags/Netty/" style="color:rgb(152,106,132);font-size:16px">Netty<span class="tag-cloud-count">(1) </span></a><a href="/tags/Nginx/" style="color:rgb(175,168,108);font-size:22px">Nginx<span class="tag-cloud-count">(1) </span></a><a href="/tags/SpringBoot/" style="color:rgb(172,164,115);font-size:15px">SpringBoot<span class="tag-cloud-count">(2) </span></a><a href="/tags/heroku/" style="color:rgb(156,128,93);font-size:17px">heroku<span class="tag-cloud-count">(1) </span></a><a href="/tags/java/" style="color:rgb(144,109,146);font-size:14px">java<span class="tag-cloud-count">(1) </span></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="color:rgb(176,119,120);font-size:20px">java基础<span class="tag-cloud-count">(2) </span></a><a href="/tags/java%E6%A0%B8%E5%BF%83/" style="color:rgb(161,171,152);font-size:15px">java核心<span class="tag-cloud-count">(1) </span></a><a href="/tags/linux/" style="color:rgb(167,153,123);font-size:13px">linux<span class="tag-cloud-count">(1) </span></a><a href="/tags/mq/" style="color:rgb(144,113,135);font-size:19px">mq<span class="tag-cloud-count">(1) </span></a><a href="/tags/mybatisPlus/" style="color:rgb(137,139,106);font-size:16px">mybatisPlus<span class="tag-cloud-count">(1) </span></a><a href="/tags/nio/" style="color:rgb(150,115,109);font-size:20px">nio<span class="tag-cloud-count">(1) </span></a><a href="/tags/servlet/" style="color:rgb(147,119,103);font-size:13px">servlet<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="color:rgb(132,167,91);font-size:20px">事务<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="color:rgb(179,165,99);font-size:20px">信号量<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="color:rgb(183,105,125);font-size:19px">分布式事务<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/" style="color:rgb(204,115,92);font-size:21px">图片识别<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" style="color:rgb(200,136,151);font-size:20px">基本命令<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="color:rgb(164,141,141);font-size:13px">小程序<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="color:rgb(146,130,91);font-size:19px">工具<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E6%80%A7%E8%83%BD/" style="color:rgb(185,121,93);font-size:20px">性能<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E6%8A%80%E5%B7%A7/" style="color:rgb(193,121,94);font-size:20px">技巧<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E7%AD%BE%E5%90%8D/" style="color:rgb(202,141,131);font-size:15px">签名<span class="tag-cloud-count">(2) </span></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="color:rgb(138,118,97);font-size:13px">设计模式<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="color:rgb(185,149,116);font-size:20px">读书笔记<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E9%98%B2%E7%9B%97%E9%93%BE/" style="color:rgb(148,165,110);font-size:14px">防盗链<span class="tag-cloud-count">(1) </span></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="color:rgb(130,138,136);font-size:19px">面试<span class="tag-cloud-count">(1) </span></a></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://www.ityouknow.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">纯洁的微笑</span></span><span class="level-right"><span class="level-item tag">www.ityouknow.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.52itstyle.vip/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">柒&#039;s</span></span><span class="level-right"><span class="level-item tag">blog.52itstyle.vip</span></span></a></li><li><a class="level is-mobile" href="https://www.wdk.pw/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">王登科</span></span><span class="level-right"><span class="level-item tag">www.wdk.pw</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><embed src="/img/footer.svg" id="galinv" type="image/svg+xml"><footer class="footer"><div class="footer-image"><img src="/img/o_cnblogs_footer.png" width="60%"></div><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">云扬四海</a><p class="is-size-7"><span>&copy; 2021 RolandLee</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yunlongn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>